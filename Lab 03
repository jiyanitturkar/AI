import heapq

# Define goal state
goal_state = (1, 2, 3, 4, 5, 6, 7, 8, 0)

# Directions: up, down, left, right (row, col)
moves = {
    'up': -3,
    'down': 3,
    'left': -1,
    'right': 1
}

# Manhattan distance lookup for each tile
def manhattan(state):
    distance = 0
    for i in range(9):
        if state[i] == 0:
            continue
        x, y = divmod(i, 3)
        goal_x, goal_y = divmod(state[i] - 1, 3)
        distance += abs(x - goal_x) + abs(y - goal_y)
    return distance

# Find possible moves
def get_neighbors(state):
    neighbors = []
    zero_index = state.index(0)
    row, col = divmod(zero_index, 3)

    def swap_and_create(new_zero):
        new_state = list(state)
        new_state[zero_index], new_state[new_zero] = new_state[new_zero], new_state[zero_index]
        return tuple(new_state)

    # Move up
    if row > 0:
        neighbors.append(swap_and_create(zero_index - 3))
    # Move down
    if row < 2:
        neighbors.append(swap_and_create(zero_index + 3))
    # Move left
    if col > 0:
        neighbors.append(swap_and_create(zero_index - 1))
    # Move right
    if col < 2:
        neighbors.append(swap_and_create(zero_index + 1))

    return neighbors

# A* algorithm
def a_star(start_state):
    frontier = []
    heapq.heappush(frontier, (manhattan(start_state), 0, start_state, []))
    visited = set()

    while frontier:
        f, g, current, path = heapq.heappop(frontier)

        if current == goal_state:
            return path + [current]

        if current in visited:
            continue
        visited.add(current)

        for neighbor in get_neighbors(current):
            if neighbor not in visited:
                new_g = g + 1
                new_f = new_g + manhattan(neighbor)
                heapq.heappush(frontier, (new_f, new_g, neighbor, path + [current]))

    return None

# Print the puzzle state nicely
def print_puzzle(state):
    for i in range(0, 9, 3):
        print(state[i:i+3])
    print()

# Example usage
if __name__ == '__main__':
    start_state = (1, 2, 3, 4, 0, 5, 6, 7, 8)  # Example start
    solution = a_star(start_state)

    if solution:
        print(f"Solution found in {len(solution)-1} moves:\n")
        for step in solution:
            print_puzzle(step)
    else:
        print("No solution found.")
