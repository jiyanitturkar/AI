import heapq

# Define the goal state
goal_state = (1, 2, 3,
              4, 5, 6,
              7, 8, 0)

# Manhattan distance heuristic
def manhattan(state):
    distance = 0
    for i in range(9):
        if state[i] == 0:
            continue  # Skip the blank tile
        x, y = divmod(i, 3)  # Current position
        goal_x, goal_y = divmod(state[i] - 1, 3)  # Goal position
        distance += abs(x - goal_x) + abs(y - goal_y)
    return distance

# Generate all possible moves from the current state
def get_neighbors(state):
    neighbors = []
    zero_index = state.index(0)
    row, col = divmod(zero_index, 3)

    def swap(pos1, pos2):
        s = list(state)
        s[pos1], s[pos2] = s[pos2], s[pos1]
        return tuple(s)

    if row > 0:  # Move up
        neighbors.append(swap(zero_index, zero_index - 3))
    if row < 2:  # Move down
        neighbors.append(swap(zero_index, zero_index + 3))
    if col > 0:  # Move left
        neighbors.append(swap(zero_index, zero_index - 1))
    if col < 2:  # Move right
        neighbors.append(swap(zero_index, zero_index + 1))

    return neighbors

# A* search algorithm
def a_star(start_state):
    frontier = []
    heapq.heappush(frontier, (manhattan(start_state), 0, start_state, []))  # (f, g, state, path)
    visited = set()

    while frontier:
        f, g, current, path = heapq.heappop(frontier)

        if current == goal_state:
            return path + [current]

        if current in visited:
            continue
        visited.add(current)

        for neighbor in get_neighbors(current):
            if neighbor not in visited:
                new_g = g + 1
                new_f = new_g + manhattan(neighbor)
                heapq.heappush(frontier, (new_f, new_g, neighbor, path + [current]))

    return None  # No solution found

# Utility function to print the puzzle in 3x3 format
def print_puzzle(state):
    for i in range(0, 9, 3):
        print(state[i:i+3])
    print()

# Main
if __name__ == '__main__':
    # Example starting state (change this to test other inputs)
    start_state = (1, 2, 3,
                   4, 0, 6,
                   7, 5, 8)

    print("Initial State:")
    print_puzzle(start_state)

    solution = a_star(start_state)

    if solution:
        print(f"Solution found in {len(solution) - 1} moves:\n")
        for i, step in enumerate(solution):
            print(f"Step {i}:")
            print_puzzle(step)
    else:
        print("No solution found.")
